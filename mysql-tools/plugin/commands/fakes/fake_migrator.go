// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"github.com/pivotal-cf/mysql-cli-plugin/mysql-tools/migrate"
	"github.com/pivotal-cf/mysql-cli-plugin/mysql-tools/plugin/commands"
)

type FakeMigrator struct {
	CheckServiceExistsStub        func(string) error
	checkServiceExistsMutex       sync.RWMutex
	checkServiceExistsArgsForCall []struct {
		arg1 string
	}
	checkServiceExistsReturns struct {
		result1 error
	}
	checkServiceExistsReturnsOnCall map[int]struct {
		result1 error
	}
	CleanupOnErrorStub        func(string) error
	cleanupOnErrorMutex       sync.RWMutex
	cleanupOnErrorArgsForCall []struct {
		arg1 string
	}
	cleanupOnErrorReturns struct {
		result1 error
	}
	cleanupOnErrorReturnsOnCall map[int]struct {
		result1 error
	}
	CreateServiceInstanceStub        func(string, string) error
	createServiceInstanceMutex       sync.RWMutex
	createServiceInstanceArgsForCall []struct {
		arg1 string
		arg2 string
	}
	createServiceInstanceReturns struct {
		result1 error
	}
	createServiceInstanceReturnsOnCall map[int]struct {
		result1 error
	}
	MigrateDataStub        func(migrate.MigrateOptions) error
	migrateDataMutex       sync.RWMutex
	migrateDataArgsForCall []struct {
		arg1 migrate.MigrateOptions
	}
	migrateDataReturns struct {
		result1 error
	}
	migrateDataReturnsOnCall map[int]struct {
		result1 error
	}
	RenameServiceInstancesStub        func(string, string) error
	renameServiceInstancesMutex       sync.RWMutex
	renameServiceInstancesArgsForCall []struct {
		arg1 string
		arg2 string
	}
	renameServiceInstancesReturns struct {
		result1 error
	}
	renameServiceInstancesReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeMigrator) CheckServiceExists(arg1 string) error {
	fake.checkServiceExistsMutex.Lock()
	ret, specificReturn := fake.checkServiceExistsReturnsOnCall[len(fake.checkServiceExistsArgsForCall)]
	fake.checkServiceExistsArgsForCall = append(fake.checkServiceExistsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.CheckServiceExistsStub
	fakeReturns := fake.checkServiceExistsReturns
	fake.recordInvocation("CheckServiceExists", []interface{}{arg1})
	fake.checkServiceExistsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMigrator) CheckServiceExistsCallCount() int {
	fake.checkServiceExistsMutex.RLock()
	defer fake.checkServiceExistsMutex.RUnlock()
	return len(fake.checkServiceExistsArgsForCall)
}

func (fake *FakeMigrator) CheckServiceExistsCalls(stub func(string) error) {
	fake.checkServiceExistsMutex.Lock()
	defer fake.checkServiceExistsMutex.Unlock()
	fake.CheckServiceExistsStub = stub
}

func (fake *FakeMigrator) CheckServiceExistsArgsForCall(i int) string {
	fake.checkServiceExistsMutex.RLock()
	defer fake.checkServiceExistsMutex.RUnlock()
	argsForCall := fake.checkServiceExistsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeMigrator) CheckServiceExistsReturns(result1 error) {
	fake.checkServiceExistsMutex.Lock()
	defer fake.checkServiceExistsMutex.Unlock()
	fake.CheckServiceExistsStub = nil
	fake.checkServiceExistsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeMigrator) CheckServiceExistsReturnsOnCall(i int, result1 error) {
	fake.checkServiceExistsMutex.Lock()
	defer fake.checkServiceExistsMutex.Unlock()
	fake.CheckServiceExistsStub = nil
	if fake.checkServiceExistsReturnsOnCall == nil {
		fake.checkServiceExistsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.checkServiceExistsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeMigrator) CleanupOnError(arg1 string) error {
	fake.cleanupOnErrorMutex.Lock()
	ret, specificReturn := fake.cleanupOnErrorReturnsOnCall[len(fake.cleanupOnErrorArgsForCall)]
	fake.cleanupOnErrorArgsForCall = append(fake.cleanupOnErrorArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.CleanupOnErrorStub
	fakeReturns := fake.cleanupOnErrorReturns
	fake.recordInvocation("CleanupOnError", []interface{}{arg1})
	fake.cleanupOnErrorMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMigrator) CleanupOnErrorCallCount() int {
	fake.cleanupOnErrorMutex.RLock()
	defer fake.cleanupOnErrorMutex.RUnlock()
	return len(fake.cleanupOnErrorArgsForCall)
}

func (fake *FakeMigrator) CleanupOnErrorCalls(stub func(string) error) {
	fake.cleanupOnErrorMutex.Lock()
	defer fake.cleanupOnErrorMutex.Unlock()
	fake.CleanupOnErrorStub = stub
}

func (fake *FakeMigrator) CleanupOnErrorArgsForCall(i int) string {
	fake.cleanupOnErrorMutex.RLock()
	defer fake.cleanupOnErrorMutex.RUnlock()
	argsForCall := fake.cleanupOnErrorArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeMigrator) CleanupOnErrorReturns(result1 error) {
	fake.cleanupOnErrorMutex.Lock()
	defer fake.cleanupOnErrorMutex.Unlock()
	fake.CleanupOnErrorStub = nil
	fake.cleanupOnErrorReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeMigrator) CleanupOnErrorReturnsOnCall(i int, result1 error) {
	fake.cleanupOnErrorMutex.Lock()
	defer fake.cleanupOnErrorMutex.Unlock()
	fake.CleanupOnErrorStub = nil
	if fake.cleanupOnErrorReturnsOnCall == nil {
		fake.cleanupOnErrorReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cleanupOnErrorReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeMigrator) CreateServiceInstance(arg1 string, arg2 string) error {
	fake.createServiceInstanceMutex.Lock()
	ret, specificReturn := fake.createServiceInstanceReturnsOnCall[len(fake.createServiceInstanceArgsForCall)]
	fake.createServiceInstanceArgsForCall = append(fake.createServiceInstanceArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.CreateServiceInstanceStub
	fakeReturns := fake.createServiceInstanceReturns
	fake.recordInvocation("CreateServiceInstance", []interface{}{arg1, arg2})
	fake.createServiceInstanceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMigrator) CreateServiceInstanceCallCount() int {
	fake.createServiceInstanceMutex.RLock()
	defer fake.createServiceInstanceMutex.RUnlock()
	return len(fake.createServiceInstanceArgsForCall)
}

func (fake *FakeMigrator) CreateServiceInstanceCalls(stub func(string, string) error) {
	fake.createServiceInstanceMutex.Lock()
	defer fake.createServiceInstanceMutex.Unlock()
	fake.CreateServiceInstanceStub = stub
}

func (fake *FakeMigrator) CreateServiceInstanceArgsForCall(i int) (string, string) {
	fake.createServiceInstanceMutex.RLock()
	defer fake.createServiceInstanceMutex.RUnlock()
	argsForCall := fake.createServiceInstanceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeMigrator) CreateServiceInstanceReturns(result1 error) {
	fake.createServiceInstanceMutex.Lock()
	defer fake.createServiceInstanceMutex.Unlock()
	fake.CreateServiceInstanceStub = nil
	fake.createServiceInstanceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeMigrator) CreateServiceInstanceReturnsOnCall(i int, result1 error) {
	fake.createServiceInstanceMutex.Lock()
	defer fake.createServiceInstanceMutex.Unlock()
	fake.CreateServiceInstanceStub = nil
	if fake.createServiceInstanceReturnsOnCall == nil {
		fake.createServiceInstanceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createServiceInstanceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeMigrator) MigrateData(arg1 migrate.MigrateOptions) error {
	fake.migrateDataMutex.Lock()
	ret, specificReturn := fake.migrateDataReturnsOnCall[len(fake.migrateDataArgsForCall)]
	fake.migrateDataArgsForCall = append(fake.migrateDataArgsForCall, struct {
		arg1 migrate.MigrateOptions
	}{arg1})
	stub := fake.MigrateDataStub
	fakeReturns := fake.migrateDataReturns
	fake.recordInvocation("MigrateData", []interface{}{arg1})
	fake.migrateDataMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMigrator) MigrateDataCallCount() int {
	fake.migrateDataMutex.RLock()
	defer fake.migrateDataMutex.RUnlock()
	return len(fake.migrateDataArgsForCall)
}

func (fake *FakeMigrator) MigrateDataCalls(stub func(migrate.MigrateOptions) error) {
	fake.migrateDataMutex.Lock()
	defer fake.migrateDataMutex.Unlock()
	fake.MigrateDataStub = stub
}

func (fake *FakeMigrator) MigrateDataArgsForCall(i int) migrate.MigrateOptions {
	fake.migrateDataMutex.RLock()
	defer fake.migrateDataMutex.RUnlock()
	argsForCall := fake.migrateDataArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeMigrator) MigrateDataReturns(result1 error) {
	fake.migrateDataMutex.Lock()
	defer fake.migrateDataMutex.Unlock()
	fake.MigrateDataStub = nil
	fake.migrateDataReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeMigrator) MigrateDataReturnsOnCall(i int, result1 error) {
	fake.migrateDataMutex.Lock()
	defer fake.migrateDataMutex.Unlock()
	fake.MigrateDataStub = nil
	if fake.migrateDataReturnsOnCall == nil {
		fake.migrateDataReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.migrateDataReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeMigrator) RenameServiceInstances(arg1 string, arg2 string) error {
	fake.renameServiceInstancesMutex.Lock()
	ret, specificReturn := fake.renameServiceInstancesReturnsOnCall[len(fake.renameServiceInstancesArgsForCall)]
	fake.renameServiceInstancesArgsForCall = append(fake.renameServiceInstancesArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.RenameServiceInstancesStub
	fakeReturns := fake.renameServiceInstancesReturns
	fake.recordInvocation("RenameServiceInstances", []interface{}{arg1, arg2})
	fake.renameServiceInstancesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMigrator) RenameServiceInstancesCallCount() int {
	fake.renameServiceInstancesMutex.RLock()
	defer fake.renameServiceInstancesMutex.RUnlock()
	return len(fake.renameServiceInstancesArgsForCall)
}

func (fake *FakeMigrator) RenameServiceInstancesCalls(stub func(string, string) error) {
	fake.renameServiceInstancesMutex.Lock()
	defer fake.renameServiceInstancesMutex.Unlock()
	fake.RenameServiceInstancesStub = stub
}

func (fake *FakeMigrator) RenameServiceInstancesArgsForCall(i int) (string, string) {
	fake.renameServiceInstancesMutex.RLock()
	defer fake.renameServiceInstancesMutex.RUnlock()
	argsForCall := fake.renameServiceInstancesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeMigrator) RenameServiceInstancesReturns(result1 error) {
	fake.renameServiceInstancesMutex.Lock()
	defer fake.renameServiceInstancesMutex.Unlock()
	fake.RenameServiceInstancesStub = nil
	fake.renameServiceInstancesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeMigrator) RenameServiceInstancesReturnsOnCall(i int, result1 error) {
	fake.renameServiceInstancesMutex.Lock()
	defer fake.renameServiceInstancesMutex.Unlock()
	fake.RenameServiceInstancesStub = nil
	if fake.renameServiceInstancesReturnsOnCall == nil {
		fake.renameServiceInstancesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.renameServiceInstancesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeMigrator) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.checkServiceExistsMutex.RLock()
	defer fake.checkServiceExistsMutex.RUnlock()
	fake.cleanupOnErrorMutex.RLock()
	defer fake.cleanupOnErrorMutex.RUnlock()
	fake.createServiceInstanceMutex.RLock()
	defer fake.createServiceInstanceMutex.RUnlock()
	fake.migrateDataMutex.RLock()
	defer fake.migrateDataMutex.RUnlock()
	fake.renameServiceInstancesMutex.RLock()
	defer fake.renameServiceInstancesMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeMigrator) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ commands.Migrator = new(FakeMigrator)
