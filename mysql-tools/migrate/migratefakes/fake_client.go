// Code generated by counterfeiter. DO NOT EDIT.
package migratefakes

import (
	"sync"

	"github.com/pivotal-cf/mysql-cli-plugin/mysql-tools/migrate"
)

type FakeClient struct {
	BindServiceStub        func(string, string) error
	bindServiceMutex       sync.RWMutex
	bindServiceArgsForCall []struct {
		arg1 string
		arg2 string
	}
	bindServiceReturns struct {
		result1 error
	}
	bindServiceReturnsOnCall map[int]struct {
		result1 error
	}
	CreateServiceInstanceStub        func(string, string) error
	createServiceInstanceMutex       sync.RWMutex
	createServiceInstanceArgsForCall []struct {
		arg1 string
		arg2 string
	}
	createServiceInstanceReturns struct {
		result1 error
	}
	createServiceInstanceReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteAppStub        func(string) error
	deleteAppMutex       sync.RWMutex
	deleteAppArgsForCall []struct {
		arg1 string
	}
	deleteAppReturns struct {
		result1 error
	}
	deleteAppReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteServiceInstanceStub        func(string) error
	deleteServiceInstanceMutex       sync.RWMutex
	deleteServiceInstanceArgsForCall []struct {
		arg1 string
	}
	deleteServiceInstanceReturns struct {
		result1 error
	}
	deleteServiceInstanceReturnsOnCall map[int]struct {
		result1 error
	}
	GetLogsStub        func(string, string) ([]string, error)
	getLogsMutex       sync.RWMutex
	getLogsArgsForCall []struct {
		arg1 string
		arg2 string
	}
	getLogsReturns struct {
		result1 []string
		result2 error
	}
	getLogsReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	PushAppStub        func(string, string) error
	pushAppMutex       sync.RWMutex
	pushAppArgsForCall []struct {
		arg1 string
		arg2 string
	}
	pushAppReturns struct {
		result1 error
	}
	pushAppReturnsOnCall map[int]struct {
		result1 error
	}
	RenameServiceStub        func(string, string) error
	renameServiceMutex       sync.RWMutex
	renameServiceArgsForCall []struct {
		arg1 string
		arg2 string
	}
	renameServiceReturns struct {
		result1 error
	}
	renameServiceReturnsOnCall map[int]struct {
		result1 error
	}
	RunTaskStub        func(string, string) error
	runTaskMutex       sync.RWMutex
	runTaskArgsForCall []struct {
		arg1 string
		arg2 string
	}
	runTaskReturns struct {
		result1 error
	}
	runTaskReturnsOnCall map[int]struct {
		result1 error
	}
	ServiceExistsStub        func(string) bool
	serviceExistsMutex       sync.RWMutex
	serviceExistsArgsForCall []struct {
		arg1 string
	}
	serviceExistsReturns struct {
		result1 bool
	}
	serviceExistsReturnsOnCall map[int]struct {
		result1 bool
	}
	StartAppStub        func(string) error
	startAppMutex       sync.RWMutex
	startAppArgsForCall []struct {
		arg1 string
	}
	startAppReturns struct {
		result1 error
	}
	startAppReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClient) BindService(arg1 string, arg2 string) error {
	fake.bindServiceMutex.Lock()
	ret, specificReturn := fake.bindServiceReturnsOnCall[len(fake.bindServiceArgsForCall)]
	fake.bindServiceArgsForCall = append(fake.bindServiceArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.BindServiceStub
	fakeReturns := fake.bindServiceReturns
	fake.recordInvocation("BindService", []interface{}{arg1, arg2})
	fake.bindServiceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) BindServiceCallCount() int {
	fake.bindServiceMutex.RLock()
	defer fake.bindServiceMutex.RUnlock()
	return len(fake.bindServiceArgsForCall)
}

func (fake *FakeClient) BindServiceCalls(stub func(string, string) error) {
	fake.bindServiceMutex.Lock()
	defer fake.bindServiceMutex.Unlock()
	fake.BindServiceStub = stub
}

func (fake *FakeClient) BindServiceArgsForCall(i int) (string, string) {
	fake.bindServiceMutex.RLock()
	defer fake.bindServiceMutex.RUnlock()
	argsForCall := fake.bindServiceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) BindServiceReturns(result1 error) {
	fake.bindServiceMutex.Lock()
	defer fake.bindServiceMutex.Unlock()
	fake.BindServiceStub = nil
	fake.bindServiceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) BindServiceReturnsOnCall(i int, result1 error) {
	fake.bindServiceMutex.Lock()
	defer fake.bindServiceMutex.Unlock()
	fake.BindServiceStub = nil
	if fake.bindServiceReturnsOnCall == nil {
		fake.bindServiceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.bindServiceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) CreateServiceInstance(arg1 string, arg2 string) error {
	fake.createServiceInstanceMutex.Lock()
	ret, specificReturn := fake.createServiceInstanceReturnsOnCall[len(fake.createServiceInstanceArgsForCall)]
	fake.createServiceInstanceArgsForCall = append(fake.createServiceInstanceArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.CreateServiceInstanceStub
	fakeReturns := fake.createServiceInstanceReturns
	fake.recordInvocation("CreateServiceInstance", []interface{}{arg1, arg2})
	fake.createServiceInstanceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) CreateServiceInstanceCallCount() int {
	fake.createServiceInstanceMutex.RLock()
	defer fake.createServiceInstanceMutex.RUnlock()
	return len(fake.createServiceInstanceArgsForCall)
}

func (fake *FakeClient) CreateServiceInstanceCalls(stub func(string, string) error) {
	fake.createServiceInstanceMutex.Lock()
	defer fake.createServiceInstanceMutex.Unlock()
	fake.CreateServiceInstanceStub = stub
}

func (fake *FakeClient) CreateServiceInstanceArgsForCall(i int) (string, string) {
	fake.createServiceInstanceMutex.RLock()
	defer fake.createServiceInstanceMutex.RUnlock()
	argsForCall := fake.createServiceInstanceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) CreateServiceInstanceReturns(result1 error) {
	fake.createServiceInstanceMutex.Lock()
	defer fake.createServiceInstanceMutex.Unlock()
	fake.CreateServiceInstanceStub = nil
	fake.createServiceInstanceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) CreateServiceInstanceReturnsOnCall(i int, result1 error) {
	fake.createServiceInstanceMutex.Lock()
	defer fake.createServiceInstanceMutex.Unlock()
	fake.CreateServiceInstanceStub = nil
	if fake.createServiceInstanceReturnsOnCall == nil {
		fake.createServiceInstanceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createServiceInstanceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DeleteApp(arg1 string) error {
	fake.deleteAppMutex.Lock()
	ret, specificReturn := fake.deleteAppReturnsOnCall[len(fake.deleteAppArgsForCall)]
	fake.deleteAppArgsForCall = append(fake.deleteAppArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DeleteAppStub
	fakeReturns := fake.deleteAppReturns
	fake.recordInvocation("DeleteApp", []interface{}{arg1})
	fake.deleteAppMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) DeleteAppCallCount() int {
	fake.deleteAppMutex.RLock()
	defer fake.deleteAppMutex.RUnlock()
	return len(fake.deleteAppArgsForCall)
}

func (fake *FakeClient) DeleteAppCalls(stub func(string) error) {
	fake.deleteAppMutex.Lock()
	defer fake.deleteAppMutex.Unlock()
	fake.DeleteAppStub = stub
}

func (fake *FakeClient) DeleteAppArgsForCall(i int) string {
	fake.deleteAppMutex.RLock()
	defer fake.deleteAppMutex.RUnlock()
	argsForCall := fake.deleteAppArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) DeleteAppReturns(result1 error) {
	fake.deleteAppMutex.Lock()
	defer fake.deleteAppMutex.Unlock()
	fake.DeleteAppStub = nil
	fake.deleteAppReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DeleteAppReturnsOnCall(i int, result1 error) {
	fake.deleteAppMutex.Lock()
	defer fake.deleteAppMutex.Unlock()
	fake.DeleteAppStub = nil
	if fake.deleteAppReturnsOnCall == nil {
		fake.deleteAppReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteAppReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DeleteServiceInstance(arg1 string) error {
	fake.deleteServiceInstanceMutex.Lock()
	ret, specificReturn := fake.deleteServiceInstanceReturnsOnCall[len(fake.deleteServiceInstanceArgsForCall)]
	fake.deleteServiceInstanceArgsForCall = append(fake.deleteServiceInstanceArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DeleteServiceInstanceStub
	fakeReturns := fake.deleteServiceInstanceReturns
	fake.recordInvocation("DeleteServiceInstance", []interface{}{arg1})
	fake.deleteServiceInstanceMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) DeleteServiceInstanceCallCount() int {
	fake.deleteServiceInstanceMutex.RLock()
	defer fake.deleteServiceInstanceMutex.RUnlock()
	return len(fake.deleteServiceInstanceArgsForCall)
}

func (fake *FakeClient) DeleteServiceInstanceCalls(stub func(string) error) {
	fake.deleteServiceInstanceMutex.Lock()
	defer fake.deleteServiceInstanceMutex.Unlock()
	fake.DeleteServiceInstanceStub = stub
}

func (fake *FakeClient) DeleteServiceInstanceArgsForCall(i int) string {
	fake.deleteServiceInstanceMutex.RLock()
	defer fake.deleteServiceInstanceMutex.RUnlock()
	argsForCall := fake.deleteServiceInstanceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) DeleteServiceInstanceReturns(result1 error) {
	fake.deleteServiceInstanceMutex.Lock()
	defer fake.deleteServiceInstanceMutex.Unlock()
	fake.DeleteServiceInstanceStub = nil
	fake.deleteServiceInstanceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DeleteServiceInstanceReturnsOnCall(i int, result1 error) {
	fake.deleteServiceInstanceMutex.Lock()
	defer fake.deleteServiceInstanceMutex.Unlock()
	fake.DeleteServiceInstanceStub = nil
	if fake.deleteServiceInstanceReturnsOnCall == nil {
		fake.deleteServiceInstanceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteServiceInstanceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) GetLogs(arg1 string, arg2 string) ([]string, error) {
	fake.getLogsMutex.Lock()
	ret, specificReturn := fake.getLogsReturnsOnCall[len(fake.getLogsArgsForCall)]
	fake.getLogsArgsForCall = append(fake.getLogsArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.GetLogsStub
	fakeReturns := fake.getLogsReturns
	fake.recordInvocation("GetLogs", []interface{}{arg1, arg2})
	fake.getLogsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) GetLogsCallCount() int {
	fake.getLogsMutex.RLock()
	defer fake.getLogsMutex.RUnlock()
	return len(fake.getLogsArgsForCall)
}

func (fake *FakeClient) GetLogsCalls(stub func(string, string) ([]string, error)) {
	fake.getLogsMutex.Lock()
	defer fake.getLogsMutex.Unlock()
	fake.GetLogsStub = stub
}

func (fake *FakeClient) GetLogsArgsForCall(i int) (string, string) {
	fake.getLogsMutex.RLock()
	defer fake.getLogsMutex.RUnlock()
	argsForCall := fake.getLogsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) GetLogsReturns(result1 []string, result2 error) {
	fake.getLogsMutex.Lock()
	defer fake.getLogsMutex.Unlock()
	fake.GetLogsStub = nil
	fake.getLogsReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetLogsReturnsOnCall(i int, result1 []string, result2 error) {
	fake.getLogsMutex.Lock()
	defer fake.getLogsMutex.Unlock()
	fake.GetLogsStub = nil
	if fake.getLogsReturnsOnCall == nil {
		fake.getLogsReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.getLogsReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PushApp(arg1 string, arg2 string) error {
	fake.pushAppMutex.Lock()
	ret, specificReturn := fake.pushAppReturnsOnCall[len(fake.pushAppArgsForCall)]
	fake.pushAppArgsForCall = append(fake.pushAppArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.PushAppStub
	fakeReturns := fake.pushAppReturns
	fake.recordInvocation("PushApp", []interface{}{arg1, arg2})
	fake.pushAppMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) PushAppCallCount() int {
	fake.pushAppMutex.RLock()
	defer fake.pushAppMutex.RUnlock()
	return len(fake.pushAppArgsForCall)
}

func (fake *FakeClient) PushAppCalls(stub func(string, string) error) {
	fake.pushAppMutex.Lock()
	defer fake.pushAppMutex.Unlock()
	fake.PushAppStub = stub
}

func (fake *FakeClient) PushAppArgsForCall(i int) (string, string) {
	fake.pushAppMutex.RLock()
	defer fake.pushAppMutex.RUnlock()
	argsForCall := fake.pushAppArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) PushAppReturns(result1 error) {
	fake.pushAppMutex.Lock()
	defer fake.pushAppMutex.Unlock()
	fake.PushAppStub = nil
	fake.pushAppReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) PushAppReturnsOnCall(i int, result1 error) {
	fake.pushAppMutex.Lock()
	defer fake.pushAppMutex.Unlock()
	fake.PushAppStub = nil
	if fake.pushAppReturnsOnCall == nil {
		fake.pushAppReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pushAppReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) RenameService(arg1 string, arg2 string) error {
	fake.renameServiceMutex.Lock()
	ret, specificReturn := fake.renameServiceReturnsOnCall[len(fake.renameServiceArgsForCall)]
	fake.renameServiceArgsForCall = append(fake.renameServiceArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.RenameServiceStub
	fakeReturns := fake.renameServiceReturns
	fake.recordInvocation("RenameService", []interface{}{arg1, arg2})
	fake.renameServiceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) RenameServiceCallCount() int {
	fake.renameServiceMutex.RLock()
	defer fake.renameServiceMutex.RUnlock()
	return len(fake.renameServiceArgsForCall)
}

func (fake *FakeClient) RenameServiceCalls(stub func(string, string) error) {
	fake.renameServiceMutex.Lock()
	defer fake.renameServiceMutex.Unlock()
	fake.RenameServiceStub = stub
}

func (fake *FakeClient) RenameServiceArgsForCall(i int) (string, string) {
	fake.renameServiceMutex.RLock()
	defer fake.renameServiceMutex.RUnlock()
	argsForCall := fake.renameServiceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) RenameServiceReturns(result1 error) {
	fake.renameServiceMutex.Lock()
	defer fake.renameServiceMutex.Unlock()
	fake.RenameServiceStub = nil
	fake.renameServiceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) RenameServiceReturnsOnCall(i int, result1 error) {
	fake.renameServiceMutex.Lock()
	defer fake.renameServiceMutex.Unlock()
	fake.RenameServiceStub = nil
	if fake.renameServiceReturnsOnCall == nil {
		fake.renameServiceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.renameServiceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) RunTask(arg1 string, arg2 string) error {
	fake.runTaskMutex.Lock()
	ret, specificReturn := fake.runTaskReturnsOnCall[len(fake.runTaskArgsForCall)]
	fake.runTaskArgsForCall = append(fake.runTaskArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.RunTaskStub
	fakeReturns := fake.runTaskReturns
	fake.recordInvocation("RunTask", []interface{}{arg1, arg2})
	fake.runTaskMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) RunTaskCallCount() int {
	fake.runTaskMutex.RLock()
	defer fake.runTaskMutex.RUnlock()
	return len(fake.runTaskArgsForCall)
}

func (fake *FakeClient) RunTaskCalls(stub func(string, string) error) {
	fake.runTaskMutex.Lock()
	defer fake.runTaskMutex.Unlock()
	fake.RunTaskStub = stub
}

func (fake *FakeClient) RunTaskArgsForCall(i int) (string, string) {
	fake.runTaskMutex.RLock()
	defer fake.runTaskMutex.RUnlock()
	argsForCall := fake.runTaskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) RunTaskReturns(result1 error) {
	fake.runTaskMutex.Lock()
	defer fake.runTaskMutex.Unlock()
	fake.RunTaskStub = nil
	fake.runTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) RunTaskReturnsOnCall(i int, result1 error) {
	fake.runTaskMutex.Lock()
	defer fake.runTaskMutex.Unlock()
	fake.RunTaskStub = nil
	if fake.runTaskReturnsOnCall == nil {
		fake.runTaskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.runTaskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) ServiceExists(arg1 string) bool {
	fake.serviceExistsMutex.Lock()
	ret, specificReturn := fake.serviceExistsReturnsOnCall[len(fake.serviceExistsArgsForCall)]
	fake.serviceExistsArgsForCall = append(fake.serviceExistsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ServiceExistsStub
	fakeReturns := fake.serviceExistsReturns
	fake.recordInvocation("ServiceExists", []interface{}{arg1})
	fake.serviceExistsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ServiceExistsCallCount() int {
	fake.serviceExistsMutex.RLock()
	defer fake.serviceExistsMutex.RUnlock()
	return len(fake.serviceExistsArgsForCall)
}

func (fake *FakeClient) ServiceExistsCalls(stub func(string) bool) {
	fake.serviceExistsMutex.Lock()
	defer fake.serviceExistsMutex.Unlock()
	fake.ServiceExistsStub = stub
}

func (fake *FakeClient) ServiceExistsArgsForCall(i int) string {
	fake.serviceExistsMutex.RLock()
	defer fake.serviceExistsMutex.RUnlock()
	argsForCall := fake.serviceExistsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ServiceExistsReturns(result1 bool) {
	fake.serviceExistsMutex.Lock()
	defer fake.serviceExistsMutex.Unlock()
	fake.ServiceExistsStub = nil
	fake.serviceExistsReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeClient) ServiceExistsReturnsOnCall(i int, result1 bool) {
	fake.serviceExistsMutex.Lock()
	defer fake.serviceExistsMutex.Unlock()
	fake.ServiceExistsStub = nil
	if fake.serviceExistsReturnsOnCall == nil {
		fake.serviceExistsReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.serviceExistsReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeClient) StartApp(arg1 string) error {
	fake.startAppMutex.Lock()
	ret, specificReturn := fake.startAppReturnsOnCall[len(fake.startAppArgsForCall)]
	fake.startAppArgsForCall = append(fake.startAppArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.StartAppStub
	fakeReturns := fake.startAppReturns
	fake.recordInvocation("StartApp", []interface{}{arg1})
	fake.startAppMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) StartAppCallCount() int {
	fake.startAppMutex.RLock()
	defer fake.startAppMutex.RUnlock()
	return len(fake.startAppArgsForCall)
}

func (fake *FakeClient) StartAppCalls(stub func(string) error) {
	fake.startAppMutex.Lock()
	defer fake.startAppMutex.Unlock()
	fake.StartAppStub = stub
}

func (fake *FakeClient) StartAppArgsForCall(i int) string {
	fake.startAppMutex.RLock()
	defer fake.startAppMutex.RUnlock()
	argsForCall := fake.startAppArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) StartAppReturns(result1 error) {
	fake.startAppMutex.Lock()
	defer fake.startAppMutex.Unlock()
	fake.StartAppStub = nil
	fake.startAppReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) StartAppReturnsOnCall(i int, result1 error) {
	fake.startAppMutex.Lock()
	defer fake.startAppMutex.Unlock()
	fake.StartAppStub = nil
	if fake.startAppReturnsOnCall == nil {
		fake.startAppReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.startAppReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.bindServiceMutex.RLock()
	defer fake.bindServiceMutex.RUnlock()
	fake.createServiceInstanceMutex.RLock()
	defer fake.createServiceInstanceMutex.RUnlock()
	fake.deleteAppMutex.RLock()
	defer fake.deleteAppMutex.RUnlock()
	fake.deleteServiceInstanceMutex.RLock()
	defer fake.deleteServiceInstanceMutex.RUnlock()
	fake.getLogsMutex.RLock()
	defer fake.getLogsMutex.RUnlock()
	fake.pushAppMutex.RLock()
	defer fake.pushAppMutex.RUnlock()
	fake.renameServiceMutex.RLock()
	defer fake.renameServiceMutex.RUnlock()
	fake.runTaskMutex.RLock()
	defer fake.runTaskMutex.RUnlock()
	fake.serviceExistsMutex.RLock()
	defer fake.serviceExistsMutex.RUnlock()
	fake.startAppMutex.RLock()
	defer fake.startAppMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ migrate.Client = new(FakeClient)
